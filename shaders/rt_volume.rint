#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable

// Intersection shader for procedural volume AABBs
// Reports the entry hit (tNear). Closest-hit will compute tFar for integration.

hitAttributeEXT vec2 hitAttribs; // unused (required by some drivers)

// Volume buffer (matches C++ GPUVolume)
struct GPUVolume {
    mat4 transform;
    vec3 scatterColor;
    float density;
    vec3 absorption;
    float anisotropy;
    vec3 emission;
    float emissionStrength;
    vec3 aabbMin;
    float pad0;
    vec3 aabbMax;
    float pad1;
};

layout(scalar, set = 0, binding = 13) readonly buffer VolumeBuffer {
    GPUVolume volumes[];
};

void main() {
    // NOTE:
    // Some toolchains/drivers do not expose gl_AABBMinEXT/gl_AABBMaxEXT in GLSL.
    // We already store the bounds per-volume in VolumeBuffer, and our TLAS volume instance uses
    // an identity transform, so object space == world space for volumes.
    vec3 ro = gl_ObjectRayOriginEXT;
    vec3 rd = gl_ObjectRayDirectionEXT;

    uint volIdx = gl_PrimitiveID;
    if (volIdx >= uint(volumes.length())) {
        return;
    }
    vec3 bmin = volumes[volIdx].aabbMin;
    vec3 bmax = volumes[volIdx].aabbMax;

    vec3 invDir = 1.0 / rd;
    vec3 t0 = (bmin - ro) * invDir;
    vec3 t1 = (bmax - ro) * invDir;
    vec3 tMin = min(t0, t1);
    vec3 tMax = max(t0, t1);

    float tNear = max(max(tMin.x, tMin.y), tMin.z);
    float tFar  = min(min(tMax.x, tMax.y), tMax.z);

    if (tNear <= tFar && tFar >= 0.0) {
        tNear = max(tNear, 0.0);
        reportIntersectionEXT(tNear, 0);
    }
}

