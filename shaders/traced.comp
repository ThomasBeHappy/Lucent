#version 450
#extension GL_EXT_scalar_block_layout : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Accumulation image (rgba32f for HDR accumulation)
layout(set = 0, binding = 0, rgba32f) uniform image2D accumImage;

// AOV images for denoiser (albedo and normal guides)
layout(set = 0, binding = 6, rgba32f) uniform image2D albedoImage;
layout(set = 0, binding = 7, rgba32f) uniform image2D normalImage;

// Scene buffers
layout(set = 0, binding = 1) readonly buffer TriangleBuffer {
    vec4 triangles[];  // Packed: v0.xyz, matId, v1.xyz, pad, v2.xyz, pad
};

layout(set = 0, binding = 2) readonly buffer BVHBuffer {
    vec4 bvhNodes[];   // Packed: aabbMin.xyz, leftFirst, aabbMax.xyz, count
};

layout(set = 0, binding = 3) readonly buffer InstanceBuffer {
    mat4 instances[];  // Transform matrices (simplified for now)
};

layout(set = 0, binding = 4) readonly buffer MaterialBuffer {
    vec4 materials[];  // baseColor, emissive, metallic/roughness/ior/flags
};

// Camera UBO
layout(set = 0, binding = 5) uniform CameraUBO {
    mat4 invView;
    mat4 invProj;
    vec3 position;
    float fov;
    vec2 resolution;
    float nearPlane;
    float farPlane;
} camera;

// Light buffer - use scalar layout to match C++ struct packing
struct GPULight {
    vec3 position;
    uint type;       // 0=Directional, 1=Point, 2=Spot, 3=Area
    vec3 color;
    float intensity;
    vec3 direction;
    float range;
    float innerAngle;
    float outerAngle;
    float areaWidth;     // Area width (rect) or radius (disk); also softness for point/spot/dir
    float areaHeight;    // Area height (rect only)
    vec3 areaTangent;    // Area light tangent
    uint areaShape;      // 0=disk, 1=rect
};

layout(scalar, set = 0, binding = 8) readonly buffer LightBuffer {
    GPULight lights[];
};

// Volume buffer - participating media instances
struct GPUVolume {
    mat4 transform;      // World to local space (inverse model)
    vec3 scatterColor;   // Scattering color
    float density;       // Volume density
    vec3 absorption;     // Absorption coefficient
    float anisotropy;    // Phase function anisotropy (-1 to 1)
    vec3 emission;       // Volume emission color
    float emissionStrength; // Emission multiplier
    vec3 aabbMin;        // World-space bounds (V1)
    float pad0;
    vec3 aabbMax;        // World-space bounds (V1)
    float pad1;
};

layout(scalar, set = 0, binding = 12) readonly buffer VolumeBuffer {
    GPUVolume volumes[];
};

// Environment map (HDR equirectangular)
layout(set = 0, binding = 9) uniform sampler2D envMap;
layout(set = 0, binding = 10) uniform sampler2D envMarginalCDF;
layout(set = 0, binding = 11) uniform sampler2D envConditionalCDF;

// Push constants
layout(push_constant) uniform PushConstants {
    uint frameIndex;
    uint sampleIndex;
    uint maxBounces;
    float clampValue;
    uint lightCount;
    float envIntensity;
    float envRotation;
    uint useEnvMap;
    uint transparentBackground;
    uint volumeCount;
    uint tileOffsetX;
    uint tileOffsetY;
    uint tileWidth;
    uint tileHeight;
} pc;

// Light types
const uint LIGHT_DIRECTIONAL = 0u;
const uint LIGHT_POINT = 1u;
const uint LIGHT_SPOT = 2u;
const uint LIGHT_AREA = 3u;

// Constants
const float PI = 3.14159265359;
const float EPSILON = 0.0001;
const float MAX_DIST = 10000.0;
// Soft shadow tuning (in world units / radians)
const float SUN_ANGULAR_RADIUS = 0.00935;
const float POINT_LIGHT_RADIUS = 0.15;

// PCG random number generator
uint pcgHash(uint v) {
    uint state = v * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float randomFloat(inout uint seed) {
    seed = pcgHash(seed);
    return float(seed) / 4294967295.0;
}

vec3 randomInUnitSphere(inout uint seed) {
    float z = randomFloat(seed) * 2.0 - 1.0;
    float a = randomFloat(seed) * 2.0 * PI;
    float r = sqrt(1.0 - z * z);
    return vec3(r * cos(a), r * sin(a), z);
}

vec3 sampleCone(vec3 axis, float cosMaxAngle, inout uint seed) {
    float u1 = randomFloat(seed);
    float u2 = randomFloat(seed);
    float cosTheta = mix(cosMaxAngle, 1.0, u1);
    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));
    float phi = 2.0 * PI * u2;
    
    vec3 w = normalize(axis);
    vec3 up = (abs(w.y) < 0.999) ? vec3(0, 1, 0) : vec3(1, 0, 0);
    vec3 u = normalize(cross(up, w));
    vec3 v = cross(w, u);
    
    return normalize(u * (cos(phi) * sinTheta) + v * (sin(phi) * sinTheta) + w * cosTheta);
}

vec3 randomCosineHemisphere(vec3 normal, inout uint seed) {
    vec3 dir = normalize(normal + randomInUnitSphere(seed));
    return dir;
}

// Sample HDR environment map (equirectangular projection)
vec3 sampleEnvironment(vec3 direction) {
    // Apply rotation around Y axis
    float c = cos(pc.envRotation);
    float s = sin(pc.envRotation);
    vec3 rotDir = vec3(c * direction.x - s * direction.z, direction.y, s * direction.x + c * direction.z);
    
    // Equirectangular mapping
    float u = atan(rotDir.z, rotDir.x) / (2.0 * PI) + 0.5;
    float v = asin(clamp(rotDir.y, -1.0, 1.0)) / PI + 0.5;
    
    if (pc.useEnvMap != 0u) {
        return texture(envMap, vec2(u, v)).rgb * pc.envIntensity;
    } else {
        // Fallback procedural sky
        float t = 0.5 * (direction.y + 1.0);
        return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t) * 0.05;
    }
}

// Importance sample environment using pre-computed CDF
vec3 sampleEnvironmentDirection(inout uint seed, out float pdf) {
    float u1 = randomFloat(seed);
    float u2 = randomFloat(seed);
    
    if (pc.useEnvMap == 0u) {
        // Uniform hemisphere sampling fallback
        float cosTheta = u1;
        float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
        float phi = 2.0 * PI * u2;
        pdf = 1.0 / (4.0 * PI);
        return vec3(cos(phi) * sinTheta, cosTheta, sin(phi) * sinTheta);
    }
    
    // Binary search in marginal CDF to find row (v coordinate)
    float v = 0.5;
    ivec2 envSize = textureSize(envMap, 0);
    
    // Simple linear search for v (could optimize with binary search)
    for (int i = 0; i < envSize.y; i++) {
        float cdfVal = texelFetch(envMarginalCDF, ivec2(i, 0), 0).r;
        if (u1 <= cdfVal) {
            float prevCdf = (i > 0) ? texelFetch(envMarginalCDF, ivec2(i - 1, 0), 0).r : 0.0;
            v = (float(i) + (u1 - prevCdf) / max(cdfVal - prevCdf, 0.0001)) / float(envSize.y);
            break;
        }
    }
    
    // Binary search in conditional CDF to find column (u coordinate)
    int row = int(v * float(envSize.y));
    row = clamp(row, 0, envSize.y - 1);
    float u = 0.5;
    
    for (int i = 0; i < envSize.x; i++) {
        float cdfVal = texelFetch(envConditionalCDF, ivec2(i, row), 0).r;
        if (u2 <= cdfVal) {
            float prevCdf = (i > 0) ? texelFetch(envConditionalCDF, ivec2(i - 1, row), 0).r : 0.0;
            u = (float(i) + (u2 - prevCdf) / max(cdfVal - prevCdf, 0.0001)) / float(envSize.x);
            break;
        }
    }
    
    // Convert UV to direction (equirectangular)
    float theta = v * PI;
    float phi = u * 2.0 * PI - PI;
    
    // Apply inverse rotation
    float c = cos(-pc.envRotation);
    float s = sin(-pc.envRotation);
    vec3 dir = vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));
    vec3 rotDir = vec3(c * dir.x - s * dir.z, dir.y, s * dir.x + c * dir.z);
    
    // Compute PDF (luminance-weighted)
    vec3 envColor = texture(envMap, vec2(u, v)).rgb;
    float lum = 0.2126 * envColor.r + 0.7152 * envColor.g + 0.0722 * envColor.b;
    float sinTheta = sin(theta);
    pdf = max(lum * float(envSize.x * envSize.y) / (2.0 * PI * PI * max(sinTheta, 0.0001)), 0.0001);
    
    return rotDir;
}

// Ray structure
struct Ray {
    vec3 origin;
    vec3 direction;
};

// Hit info
struct HitInfo {
    float t;
    vec3 position;
    vec3 normal;
    uint materialId;
    bool hit;
};

// Volume hit info
struct VolumeHit {
    bool hit;
    float tNear;
    float tFar;
    uint volumeIdx;
};

// Ray-AABB intersection for volumes (returns entry/exit distances)
bool intersectVolumeAABB(vec3 ro, vec3 rd, out float tNear, out float tFar) {
    vec3 invDir = 1.0 / rd;
    vec3 t0 = (-0.5 - ro) * invDir;
    vec3 t1 = (0.5 - ro) * invDir;
    vec3 tMin = min(t0, t1);
    vec3 tMax = max(t0, t1);
    tNear = max(max(tMin.x, tMin.y), tMin.z);
    tFar = min(min(tMax.x, tMax.y), tMax.z);
    return tNear <= tFar && tFar >= 0.0;
}

// Find closest volume intersection
VolumeHit findVolumeHit(Ray ray, float maxT) {
    VolumeHit result;
    result.hit = false;
    result.tNear = MAX_DIST;
    result.tFar = 0.0;
    result.volumeIdx = 0u;
    
    for (uint i = 0u; i < pc.volumeCount; i++) {
        // World-space ray vs world-space AABB (V1)
        vec3 aabbMin = volumes[i].aabbMin;
        vec3 aabbMax = volumes[i].aabbMax;
        vec3 invDir = 1.0 / ray.direction;
        vec3 t0 = (aabbMin - ray.origin) * invDir;
        vec3 t1 = (aabbMax - ray.origin) * invDir;
        vec3 tMin = min(t0, t1);
        vec3 tMaxV = max(t0, t1);
        float tN = max(max(tMin.x, tMin.y), tMin.z);
        float tF = min(min(tMaxV.x, tMaxV.y), tMaxV.z);
        
        if (tN <= tF && tF >= 0.0) {
            tN = max(tN, 0.0);
            if (tN < result.tNear && tN < maxT) {
                result.hit = true;
                result.tNear = tN;
                result.tFar = min(tF, maxT);
                result.volumeIdx = i;
            }
        }
    }
    
    return result;
}

// Henyey-Greenstein phase function
float phaseHG(float cosTheta, float g) {
    float g2 = g * g;
    return (1.0 - g2) / (4.0 * PI * pow(1.0 + g2 - 2.0 * g * cosTheta, 1.5));
}

// Integrate volume along ray segment (homogeneous medium, single scatter)
vec4 integrateVolume(Ray ray, float tNear, float tFar, uint volIdx, inout uint seed) {
    GPUVolume vol = volumes[volIdx];
    
    const int MAX_STEPS = 32;
    float stepSize = (tFar - tNear) / float(MAX_STEPS);
    
    vec3 accumColor = vec3(0.0);
    float transmittance = 1.0;
    
    // Get dominant light direction for single scattering
    vec3 lightDir = normalize(vec3(1.0, 1.0, 0.5));
    vec3 lightColor = vec3(2.5);
    if (pc.lightCount > 0u) {
        lightDir = lights[0].direction;
        lightColor = lights[0].color * lights[0].intensity;
    }
    
    for (int i = 0; i < MAX_STEPS; i++) {
        float t = tNear + (float(i) + 0.5) * stepSize;
        
        // Extinction coefficient
        float sigma_t = vol.density;
        
        // Transmittance through this step (Beer-Lambert)
        float stepTransmittance = exp(-sigma_t * stepSize);
        
        // Phase function
        float cosTheta = dot(-ray.direction, lightDir);
        float phase = phaseHG(cosTheta, vol.anisotropy);
        
        // In-scattering (simplified single scatter)
        vec3 scattering = vol.scatterColor * vol.density * lightColor * phase;
        
        // Add emission
        scattering += vol.emission * vol.emissionStrength;
        
        // Integrate
        accumColor += transmittance * scattering * stepSize;
        transmittance *= stepTransmittance;
        
        // Early termination
        if (transmittance < 0.01) break;
    }
    
    float alpha = 1.0 - transmittance;
    return vec4(accumColor, alpha);
}

// Generate camera ray
Ray generateRay(vec2 uv) {
    // Convert to NDC (-1 to 1)
    vec2 ndc = uv * 2.0 - 1.0;
    
    // Unproject
    vec4 clipPos = vec4(ndc, -1.0, 1.0);
    vec4 viewPos = camera.invProj * clipPos;
    viewPos = viewPos / viewPos.w;
    
    vec4 worldPos = camera.invView * viewPos;
    
    Ray ray;
    ray.origin = camera.position;
    ray.direction = normalize(worldPos.xyz - camera.position);
    
    return ray;
}

// Ray-triangle intersection (MÃ¶ller-Trumbore)
bool intersectTriangle(Ray ray, vec3 v0, vec3 v1, vec3 v2, out float t, out vec3 normal) {
    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;
    vec3 h = cross(ray.direction, e2);
    float a = dot(e1, h);
    
    if (abs(a) < EPSILON) return false;
    
    float f = 1.0 / a;
    vec3 s = ray.origin - v0;
    float u = f * dot(s, h);
    
    if (u < 0.0 || u > 1.0) return false;
    
    vec3 q = cross(s, e1);
    float v = f * dot(ray.direction, q);
    
    if (v < 0.0 || u + v > 1.0) return false;
    
    t = f * dot(e2, q);
    
    if (t > EPSILON) {
        normal = normalize(cross(e1, e2));
        return true;
    }
    
    return false;
}

// Ray-AABB intersection
bool intersectAABB(Ray ray, vec3 aabbMin, vec3 aabbMax, float tMax) {
    vec3 invDir = 1.0 / ray.direction;
    vec3 t0 = (aabbMin - ray.origin) * invDir;
    vec3 t1 = (aabbMax - ray.origin) * invDir;
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);
    float tNear = max(max(tmin.x, tmin.y), tmin.z);
    float tFar = min(min(tmax.x, tmax.y), tmax.z);
    return tNear <= tFar && tNear < tMax && tFar > 0.0;
}

// Trace ray against scene (simplified - traverse all triangles for now)
HitInfo traceRay(Ray ray) {
    HitInfo hit;
    hit.t = MAX_DIST;
    hit.hit = false;
    
    uint numTriangles = triangles.length() / 3;  // 3 vec4s per triangle
    
    for (uint i = 0; i < numTriangles; i++) {
        vec4 t0 = triangles[i * 3 + 0];
        vec4 t1 = triangles[i * 3 + 1];
        vec4 t2 = triangles[i * 3 + 2];
        
        vec3 v0 = t0.xyz;
        vec3 v1 = t1.xyz;
        vec3 v2 = t2.xyz;
        uint matId = floatBitsToUint(t0.w);
        
        float t;
        vec3 normal;
        if (intersectTriangle(ray, v0, v1, v2, t, normal)) {
            if (t < hit.t) {
                hit.t = t;
                hit.position = ray.origin + ray.direction * t;
                hit.normal = normal;
                hit.materialId = matId;
                hit.hit = true;
            }
        }
    }
    
    return hit;
}

// Path trace result with AOVs
struct PathTraceResult {
    vec3 radiance;
    vec3 albedo;   // First-hit albedo for denoiser
    vec3 normal;   // First-hit normal for denoiser
    bool hitPrimary;
};

// Path trace
PathTraceResult pathTrace(Ray ray, inout uint seed) {
    PathTraceResult result;
    result.radiance = vec3(0.0);
    result.albedo = vec3(0.0);
    result.normal = vec3(0.0);
    result.hitPrimary = false;
    
    vec3 throughput = vec3(1.0);
    bool firstHit = true;
    
    for (uint bounce = 0; bounce <= pc.maxBounces; bounce++) {
        HitInfo hit = traceRay(ray);
        
        // Check for volume intersection (if we have volumes)
        if (pc.volumeCount > 0u) {
            float maxT = hit.hit ? hit.t : MAX_DIST;
            VolumeHit volHit = findVolumeHit(ray, maxT);
            
            if (volHit.hit) {
                // Integrate volume
                vec4 volResult = integrateVolume(ray, volHit.tNear, volHit.tFar, volHit.volumeIdx, seed);
                
                // Apply volume contribution with premultiplied alpha
                result.radiance += throughput * volResult.rgb;
                throughput *= (1.0 - volResult.a);

                if (firstHit) {
                    result.hitPrimary = true;
                }
                
                // If volume is opaque, stop tracing
                if (volResult.a > 0.99) {
                    if (firstHit) {
                        result.albedo = volumes[volHit.volumeIdx].scatterColor;
                        result.normal = vec3(0.5); // Neutral normal for volumes
                    }
                    break;
                }
            }
        }
        
        if (!hit.hit) {
            // Sky color (simple gradient)
            // Sample environment map
            vec3 envColor = sampleEnvironment(ray.direction);
            if (pc.transparentBackground == 0u || !firstHit) {
                result.radiance += throughput * envColor;
            }
            
            // For sky hits on first bounce, use env as albedo
            if (firstHit) {
                if (pc.transparentBackground == 0u) {
                    result.albedo = envColor;
                    result.normal = -ray.direction;  // Normal pointing back at camera
                } else {
                    result.albedo = vec3(0.0);
                    result.normal = vec3(0.5);
                }
            }
            break;
        }
        
        // Get material
        uint matIdx = hit.materialId;
        vec4 baseColor = materials[matIdx * 3 + 0];
        vec4 emissive = materials[matIdx * 3 + 1];
        vec4 props = materials[matIdx * 3 + 2];
        
        float metallic = props.x;
        float roughness = props.y;
        
        // Ensure normal faces the ray
        vec3 normal = hit.normal;
        if (dot(normal, ray.direction) > 0.0) {
            normal = -normal;
        }
        
        // Capture first-hit AOVs for denoiser
        if (firstHit) {
            result.hitPrimary = true;
            result.albedo = baseColor.rgb;
            result.normal = normal * 0.5 + 0.5;  // Remap to [0,1] for storage
            firstHit = false;
        }
        
        // Add emission
        result.radiance += throughput * emissive.rgb * emissive.a;
        
        // Direct lighting from scene lights
        uint numLights = lights.length();
        for (uint i = 0; i < numLights; i++) {
            GPULight light = lights[i];
            
            vec3 lightDir;
            float lightDist = MAX_DIST;
            float attenuation = 1.0;
            vec3 sampledPos = light.position;
            
            if (light.type == LIGHT_DIRECTIONAL) {
                // Soft sun: sample direction within angular radius (consistent with RT pipeline)
                float angularRadius = (light.areaWidth > 0.0) ? light.areaWidth : SUN_ANGULAR_RADIUS;
                float cosMax = cos(angularRadius);
                lightDir = sampleCone(normalize(light.direction), cosMax, seed);
            } else if (light.type == LIGHT_AREA) {
                // Area light - sample a point on the surface
                vec3 tangent = light.areaTangent;
                vec3 bitangent = cross(light.direction, tangent);
                
                if (light.areaShape == 0u) {
                    // Disk - sample random point in disk
                    float r = sqrt(randomFloat(seed)) * light.areaWidth;
                    float angle = randomFloat(seed) * 2.0 * PI;
                    sampledPos = light.position + tangent * (r * cos(angle)) + bitangent * (r * sin(angle));
                } else {
                    // Rect - sample random point on rectangle
                    float u = (randomFloat(seed) - 0.5) * light.areaWidth;
                    float v = (randomFloat(seed) - 0.5) * light.areaHeight;
                    sampledPos = light.position + tangent * u + bitangent * v;
                }
                
                vec3 toLight = sampledPos - hit.position;
                lightDist = length(toLight);
                lightDir = toLight / lightDist;
                
                // Check if we're on the lit side of the area light
                float cosAngle = dot(-lightDir, light.direction);
                if (cosAngle < 0.0) continue;  // Back side of area light
                
                // Distance attenuation with cosine falloff for area lights
                if (light.range > 0.0) {
                    attenuation = 1.0 - clamp(lightDist / light.range, 0.0, 1.0);
                    attenuation *= attenuation;
                } else {
                    attenuation = 1.0 / (lightDist * lightDist + 1.0);
                }
                attenuation *= cosAngle;  // Cosine falloff from area light normal
            } else if (light.type == LIGHT_POINT || light.type == LIGHT_SPOT) {
                // Point/Spot light - use per-light softness or fallback to default
                float softRadius = (light.areaWidth > 0.0) ? light.areaWidth : POINT_LIGHT_RADIUS;
                sampledPos = light.position + randomInUnitSphere(seed) * softRadius;
                vec3 toLight = sampledPos - hit.position;
                lightDist = length(toLight);
                lightDir = toLight / lightDist;
                
                // Distance attenuation
                if (light.range > 0.0) {
                    attenuation = 1.0 - clamp(lightDist / light.range, 0.0, 1.0);
                    attenuation *= attenuation; // Quadratic falloff
                } else {
                    attenuation = 1.0 / (lightDist * lightDist + 1.0);
                }
                
                // Spot light cone
                if (light.type == LIGHT_SPOT) {
                    float theta = dot(-lightDir, light.direction);
                    float cosInner = cos(light.innerAngle);
                    float cosOuter = cos(light.outerAngle);
                    float denom = max(cosInner - cosOuter, 0.0001);
                    float spotFactor = clamp((theta - cosOuter) / denom, 0.0, 1.0);
                    attenuation *= spotFactor;
                }
            } else {
                continue; // Skip unsupported light types
            }
            
            float NdotL = max(dot(normal, lightDir), 0.0);
            if (NdotL <= 0.0 || attenuation <= 0.0) continue;
            
            // Shadow ray
            Ray shadowRay;
            shadowRay.origin = hit.position + normal * EPSILON;
            shadowRay.direction = lightDir;
            
            HitInfo shadowHit = traceRay(shadowRay);
            if (light.type == LIGHT_DIRECTIONAL) {
                if (shadowHit.hit) continue;
            } else {
                // Point, spot, and area lights - check if shadow hit is before the light
                if (shadowHit.hit && shadowHit.t < lightDist - EPSILON) {
                    continue; // In shadow
                }
            }
            
            // Diffuse contribution
            vec3 diffuse = baseColor.rgb * (1.0 - metallic);
            vec3 lightContrib = diffuse * light.color * light.intensity * NdotL * attenuation / PI;
            result.radiance += throughput * lightContrib;
        }
        
        // Indirect bounce - Lambertian
        ray.origin = hit.position + normal * EPSILON;
        ray.direction = randomCosineHemisphere(normal, seed);
        
        // Update throughput
        throughput *= baseColor.rgb;
        
        // Russian roulette
        if (bounce > 2) {
            float p = max(throughput.x, max(throughput.y, throughput.z));
            if (randomFloat(seed) > p) break;
            throughput /= p;
        }
    }
    
    // Clamp fireflies
    if (pc.clampValue > 0.0) {
        float luminance = dot(result.radiance, vec3(0.2126, 0.7152, 0.0722));
        if (luminance > pc.clampValue) {
            result.radiance *= pc.clampValue / luminance;
        }
    }
    
    return result;
}

void main() {
    ivec2 localCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(accumImage);
    
    // Tile bounds (local dispatch coords)
    if (localCoord.x >= int(pc.tileWidth) || localCoord.y >= int(pc.tileHeight)) {
        return;
    }

    ivec2 pixelCoord = localCoord + ivec2(int(pc.tileOffsetX), int(pc.tileOffsetY));

    if (pixelCoord.x >= imageSize.x || pixelCoord.y >= imageSize.y) {
        return;
    }
    
    // Initialize RNG seed
    uint seed = pcgHash(pixelCoord.x + pixelCoord.y * imageSize.x + pc.frameIndex * 1000000u + pc.sampleIndex * 10000u);
    
    // Jittered UV for anti-aliasing
    vec2 jitter = vec2(randomFloat(seed), randomFloat(seed)) - 0.5;
    vec2 uv = (vec2(pixelCoord) + 0.5 + jitter) / vec2(imageSize);
    
    // Generate ray and trace
    Ray ray = generateRay(uv);
    PathTraceResult result = pathTrace(ray, seed);
    
    // Accumulate color
    vec4 prevColor = imageLoad(accumImage, pixelCoord);
    float sampleWeight = 1.0 / float(pc.sampleIndex + 1);
    vec3 accumulated = mix(prevColor.rgb, result.radiance, sampleWeight);
    float sampleAlpha = (pc.transparentBackground != 0u && !result.hitPrimary) ? 0.0 : 1.0;
    float accumulatedAlpha = mix(prevColor.a, sampleAlpha, sampleWeight);
    imageStore(accumImage, pixelCoord, vec4(accumulated, accumulatedAlpha));
    
    // Accumulate AOVs (albedo and normal - these converge quickly)
    vec4 prevAlbedo = imageLoad(albedoImage, pixelCoord);
    vec4 prevNormal = imageLoad(normalImage, pixelCoord);
    vec3 accumAlbedo = mix(prevAlbedo.rgb, result.albedo, sampleWeight);
    vec3 accumNormal = mix(prevNormal.rgb, result.normal, sampleWeight);
    imageStore(albedoImage, pixelCoord, vec4(accumAlbedo, 1.0));
    imageStore(normalImage, pixelCoord, vec4(accumNormal, 1.0));
}
