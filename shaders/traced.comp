#version 450
#extension GL_EXT_scalar_block_layout : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Accumulation image (rgba32f for HDR accumulation)
layout(set = 0, binding = 0, rgba32f) uniform image2D accumImage;

// AOV images for denoiser (albedo and normal guides)
layout(set = 0, binding = 6, rgba32f) uniform image2D albedoImage;
layout(set = 0, binding = 7, rgba32f) uniform image2D normalImage;

// Scene buffers
layout(set = 0, binding = 1) readonly buffer TriangleBuffer {
    vec4 triangles[];  // Packed: v0.xyz, matId, v1.xyz, pad, v2.xyz, pad
};

layout(set = 0, binding = 2) readonly buffer BVHBuffer {
    vec4 bvhNodes[];   // Packed: aabbMin.xyz, leftFirst, aabbMax.xyz, count
};

layout(set = 0, binding = 3) readonly buffer InstanceBuffer {
    mat4 instances[];  // Transform matrices (simplified for now)
};

layout(set = 0, binding = 4) readonly buffer MaterialBuffer {
    vec4 materials[];  // baseColor, emissive, metallic/roughness/ior/flags
};

// Camera UBO
layout(set = 0, binding = 5) uniform CameraUBO {
    mat4 invView;
    mat4 invProj;
    vec3 position;
    float fov;
    vec2 resolution;
    float nearPlane;
    float farPlane;
} camera;

// Light buffer - use scalar layout to match C++ struct packing
struct GPULight {
    vec3 position;
    uint type;       // 0=Directional, 1=Point, 2=Spot, 3=Area
    vec3 color;
    float intensity;
    vec3 direction;
    float range;
    float innerAngle;
    float outerAngle;
    vec2 padding;
};

layout(scalar, set = 0, binding = 8) readonly buffer LightBuffer {
    GPULight lights[];
};

// Push constants
layout(push_constant) uniform PushConstants {
    uint frameIndex;
    uint sampleIndex;
    uint maxBounces;
    float clampValue;
} pc;

// Light types
const uint LIGHT_DIRECTIONAL = 0u;
const uint LIGHT_POINT = 1u;
const uint LIGHT_SPOT = 2u;
const uint LIGHT_AREA = 3u;

// Constants
const float PI = 3.14159265359;
const float EPSILON = 0.0001;
const float MAX_DIST = 10000.0;
// Soft shadow tuning (in world units / radians)
const float SUN_ANGULAR_RADIUS = 0.00935;
const float POINT_LIGHT_RADIUS = 0.15;

// PCG random number generator
uint pcgHash(uint v) {
    uint state = v * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float randomFloat(inout uint seed) {
    seed = pcgHash(seed);
    return float(seed) / 4294967295.0;
}

vec3 randomInUnitSphere(inout uint seed) {
    float z = randomFloat(seed) * 2.0 - 1.0;
    float a = randomFloat(seed) * 2.0 * PI;
    float r = sqrt(1.0 - z * z);
    return vec3(r * cos(a), r * sin(a), z);
}

vec3 sampleCone(vec3 axis, float cosMaxAngle, inout uint seed) {
    float u1 = randomFloat(seed);
    float u2 = randomFloat(seed);
    float cosTheta = mix(cosMaxAngle, 1.0, u1);
    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));
    float phi = 2.0 * PI * u2;
    
    vec3 w = normalize(axis);
    vec3 up = (abs(w.y) < 0.999) ? vec3(0, 1, 0) : vec3(1, 0, 0);
    vec3 u = normalize(cross(up, w));
    vec3 v = cross(w, u);
    
    return normalize(u * (cos(phi) * sinTheta) + v * (sin(phi) * sinTheta) + w * cosTheta);
}

vec3 randomCosineHemisphere(vec3 normal, inout uint seed) {
    vec3 dir = normalize(normal + randomInUnitSphere(seed));
    return dir;
}

// Ray structure
struct Ray {
    vec3 origin;
    vec3 direction;
};

// Hit info
struct HitInfo {
    float t;
    vec3 position;
    vec3 normal;
    uint materialId;
    bool hit;
};

// Generate camera ray
Ray generateRay(vec2 uv) {
    // Convert to NDC (-1 to 1)
    vec2 ndc = uv * 2.0 - 1.0;
    
    // Unproject
    vec4 clipPos = vec4(ndc, -1.0, 1.0);
    vec4 viewPos = camera.invProj * clipPos;
    viewPos = viewPos / viewPos.w;
    
    vec4 worldPos = camera.invView * viewPos;
    
    Ray ray;
    ray.origin = camera.position;
    ray.direction = normalize(worldPos.xyz - camera.position);
    
    return ray;
}

// Ray-triangle intersection (MÃ¶ller-Trumbore)
bool intersectTriangle(Ray ray, vec3 v0, vec3 v1, vec3 v2, out float t, out vec3 normal) {
    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;
    vec3 h = cross(ray.direction, e2);
    float a = dot(e1, h);
    
    if (abs(a) < EPSILON) return false;
    
    float f = 1.0 / a;
    vec3 s = ray.origin - v0;
    float u = f * dot(s, h);
    
    if (u < 0.0 || u > 1.0) return false;
    
    vec3 q = cross(s, e1);
    float v = f * dot(ray.direction, q);
    
    if (v < 0.0 || u + v > 1.0) return false;
    
    t = f * dot(e2, q);
    
    if (t > EPSILON) {
        normal = normalize(cross(e1, e2));
        return true;
    }
    
    return false;
}

// Ray-AABB intersection
bool intersectAABB(Ray ray, vec3 aabbMin, vec3 aabbMax, float tMax) {
    vec3 invDir = 1.0 / ray.direction;
    vec3 t0 = (aabbMin - ray.origin) * invDir;
    vec3 t1 = (aabbMax - ray.origin) * invDir;
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);
    float tNear = max(max(tmin.x, tmin.y), tmin.z);
    float tFar = min(min(tmax.x, tmax.y), tmax.z);
    return tNear <= tFar && tNear < tMax && tFar > 0.0;
}

// Trace ray against scene (simplified - traverse all triangles for now)
HitInfo traceRay(Ray ray) {
    HitInfo hit;
    hit.t = MAX_DIST;
    hit.hit = false;
    
    uint numTriangles = triangles.length() / 3;  // 3 vec4s per triangle
    
    for (uint i = 0; i < numTriangles; i++) {
        vec4 t0 = triangles[i * 3 + 0];
        vec4 t1 = triangles[i * 3 + 1];
        vec4 t2 = triangles[i * 3 + 2];
        
        vec3 v0 = t0.xyz;
        vec3 v1 = t1.xyz;
        vec3 v2 = t2.xyz;
        uint matId = floatBitsToUint(t0.w);
        
        float t;
        vec3 normal;
        if (intersectTriangle(ray, v0, v1, v2, t, normal)) {
            if (t < hit.t) {
                hit.t = t;
                hit.position = ray.origin + ray.direction * t;
                hit.normal = normal;
                hit.materialId = matId;
                hit.hit = true;
            }
        }
    }
    
    return hit;
}

// Path trace result with AOVs
struct PathTraceResult {
    vec3 radiance;
    vec3 albedo;   // First-hit albedo for denoiser
    vec3 normal;   // First-hit normal for denoiser
};

// Path trace
PathTraceResult pathTrace(Ray ray, inout uint seed) {
    PathTraceResult result;
    result.radiance = vec3(0.0);
    result.albedo = vec3(0.0);
    result.normal = vec3(0.0);
    
    vec3 throughput = vec3(1.0);
    bool firstHit = true;
    
    for (uint bounce = 0; bounce <= pc.maxBounces; bounce++) {
        HitInfo hit = traceRay(ray);
        
        if (!hit.hit) {
            // Sky color (simple gradient)
            float t = 0.5 * (ray.direction.y + 1.0);
            // Keep the environment relatively dim so explicit scene lights dominate.
            vec3 skyColor = mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t) * 0.05;
            result.radiance += throughput * skyColor;
            
            // For sky hits on first bounce, use sky as albedo
            if (firstHit) {
                result.albedo = skyColor;
                result.normal = -ray.direction;  // Normal pointing back at camera
            }
            break;
        }
        
        // Get material
        uint matIdx = hit.materialId;
        vec4 baseColor = materials[matIdx * 3 + 0];
        vec4 emissive = materials[matIdx * 3 + 1];
        vec4 props = materials[matIdx * 3 + 2];
        
        float metallic = props.x;
        float roughness = props.y;
        
        // Ensure normal faces the ray
        vec3 normal = hit.normal;
        if (dot(normal, ray.direction) > 0.0) {
            normal = -normal;
        }
        
        // Capture first-hit AOVs for denoiser
        if (firstHit) {
            result.albedo = baseColor.rgb;
            result.normal = normal * 0.5 + 0.5;  // Remap to [0,1] for storage
            firstHit = false;
        }
        
        // Add emission
        result.radiance += throughput * emissive.rgb * emissive.a;
        
        // Direct lighting from scene lights
        uint numLights = lights.length();
        for (uint i = 0; i < numLights; i++) {
            GPULight light = lights[i];
            
            vec3 lightDir;
            float lightDist = MAX_DIST;
            float attenuation = 1.0;
            vec3 sampledPos = light.position;
            
            if (light.type == LIGHT_DIRECTIONAL) {
                // Directional light - direction points toward light
                float cosMax = cos(SUN_ANGULAR_RADIUS);
                lightDir = sampleCone(light.direction, cosMax, seed);
            } else if (light.type == LIGHT_POINT || light.type == LIGHT_SPOT) {
                // Point/Spot light
                sampledPos = light.position + randomInUnitSphere(seed) * POINT_LIGHT_RADIUS;
                vec3 toLight = sampledPos - hit.position;
                lightDist = length(toLight);
                lightDir = toLight / lightDist;
                
                // Distance attenuation
                if (light.range > 0.0) {
                    attenuation = 1.0 - clamp(lightDist / light.range, 0.0, 1.0);
                    attenuation *= attenuation; // Quadratic falloff
                } else {
                    attenuation = 1.0 / (lightDist * lightDist + 1.0);
                }
                
                // Spot light cone
                if (light.type == LIGHT_SPOT) {
                    float theta = dot(-lightDir, light.direction);
                    float cosInner = cos(light.innerAngle);
                    float cosOuter = cos(light.outerAngle);
                    float denom = max(cosInner - cosOuter, 0.0001);
                    float spotFactor = clamp((theta - cosOuter) / denom, 0.0, 1.0);
                    attenuation *= spotFactor;
                }
            } else {
                continue; // Skip unsupported light types
            }
            
            float NdotL = max(dot(normal, lightDir), 0.0);
            if (NdotL <= 0.0 || attenuation <= 0.0) continue;
            
            // Shadow ray
            Ray shadowRay;
            shadowRay.origin = hit.position + normal * EPSILON;
            shadowRay.direction = lightDir;
            
            HitInfo shadowHit = traceRay(shadowRay);
            if (light.type == LIGHT_DIRECTIONAL) {
                if (shadowHit.hit) continue;
            } else {
                if (shadowHit.hit && shadowHit.t < lightDist - EPSILON) {
                    continue; // In shadow
                }
            }
            
            // Diffuse contribution
            vec3 diffuse = baseColor.rgb * (1.0 - metallic);
            vec3 lightContrib = diffuse * light.color * light.intensity * NdotL * attenuation / PI;
            result.radiance += throughput * lightContrib;
        }
        
        // Indirect bounce - Lambertian
        ray.origin = hit.position + normal * EPSILON;
        ray.direction = randomCosineHemisphere(normal, seed);
        
        // Update throughput
        throughput *= baseColor.rgb;
        
        // Russian roulette
        if (bounce > 2) {
            float p = max(throughput.x, max(throughput.y, throughput.z));
            if (randomFloat(seed) > p) break;
            throughput /= p;
        }
    }
    
    // Clamp fireflies
    if (pc.clampValue > 0.0) {
        float luminance = dot(result.radiance, vec3(0.2126, 0.7152, 0.0722));
        if (luminance > pc.clampValue) {
            result.radiance *= pc.clampValue / luminance;
        }
    }
    
    return result;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(accumImage);
    
    if (pixelCoord.x >= imageSize.x || pixelCoord.y >= imageSize.y) {
        return;
    }
    
    // Initialize RNG seed
    uint seed = pcgHash(pixelCoord.x + pixelCoord.y * imageSize.x + pc.frameIndex * 1000000u + pc.sampleIndex * 10000u);
    
    // Jittered UV for anti-aliasing
    vec2 jitter = vec2(randomFloat(seed), randomFloat(seed)) - 0.5;
    vec2 uv = (vec2(pixelCoord) + 0.5 + jitter) / vec2(imageSize);
    
    // Generate ray and trace
    Ray ray = generateRay(uv);
    PathTraceResult result = pathTrace(ray, seed);
    
    // Accumulate color
    vec4 prevColor = imageLoad(accumImage, pixelCoord);
    float sampleWeight = 1.0 / float(pc.sampleIndex + 1);
    vec3 accumulated = mix(prevColor.rgb, result.radiance, sampleWeight);
    imageStore(accumImage, pixelCoord, vec4(accumulated, 1.0));
    
    // Accumulate AOVs (albedo and normal - these converge quickly)
    vec4 prevAlbedo = imageLoad(albedoImage, pixelCoord);
    vec4 prevNormal = imageLoad(normalImage, pixelCoord);
    vec3 accumAlbedo = mix(prevAlbedo.rgb, result.albedo, sampleWeight);
    vec3 accumNormal = mix(prevNormal.rgb, result.normal, sampleWeight);
    imageStore(albedoImage, pixelCoord, vec4(accumAlbedo, 1.0));
    imageStore(normalImage, pixelCoord, vec4(accumNormal, 1.0));
}

