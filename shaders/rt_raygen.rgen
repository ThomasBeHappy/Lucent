#version 460
#extension GL_EXT_ray_tracing : require

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba32f) uniform image2D accumImage;

layout(set = 0, binding = 5) uniform CameraUBO {
    mat4 invView;
    mat4 invProj;
    vec3 position;
    float fov;
    vec2 resolution;
    float nearPlane;
    float farPlane;
} camera;

layout(push_constant) uniform PushConstants {
    uint frameIndex;
    uint sampleIndex;
    uint maxBounces;
    float clampValue;
} pc;

layout(location = 0) rayPayloadEXT vec3 payload;

// PCG random
uint pcgHash(uint v) {
    uint state = v * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float randomFloat(inout uint seed) {
    seed = pcgHash(seed);
    return float(seed) / 4294967295.0;
}

void main() {
    const uvec2 pixel = gl_LaunchIDEXT.xy;
    const uvec2 size = gl_LaunchSizeEXT.xy;
    
    // Initialize RNG
    uint seed = pcgHash(pixel.x + pixel.y * size.x + pc.frameIndex * 1000000u + pc.sampleIndex * 10000u);
    
    // Jittered UV for anti-aliasing
    vec2 jitter = vec2(randomFloat(seed), randomFloat(seed)) - 0.5;
    vec2 uv = (vec2(pixel) + 0.5 + jitter) / vec2(size);
    
    // Generate ray
    vec2 ndc = uv * 2.0 - 1.0;
    vec4 clipPos = vec4(ndc, -1.0, 1.0);
    vec4 viewPos = camera.invProj * clipPos;
    viewPos = viewPos / viewPos.w;
    vec4 worldPos = camera.invView * viewPos;
    
    vec3 origin = camera.position;
    vec3 direction = normalize(worldPos.xyz - camera.position);
    
    float tMin = 0.001;
    float tMax = 10000.0;
    
    // Trace ray
    payload = vec3(0.0);
    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF,
                0, 0, 0, origin, tMin, direction, tMax, 0);
    
    // Clamp fireflies
    vec3 color = payload;
    if (pc.clampValue > 0.0) {
        float luminance = dot(color, vec3(0.2126, 0.7152, 0.0722));
        if (luminance > pc.clampValue) {
            color *= pc.clampValue / luminance;
        }
    }
    
    // Accumulate
    vec4 prevColor = imageLoad(accumImage, ivec2(pixel));
    float sampleWeight = 1.0 / float(pc.sampleIndex + 1);
    vec3 accumulated = mix(prevColor.rgb, color, sampleWeight);
    
    imageStore(accumImage, ivec2(pixel), vec4(accumulated, 1.0));
}


