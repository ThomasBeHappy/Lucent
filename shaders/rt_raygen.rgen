#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba32f) uniform image2D accumImage;

// AOV images for denoiser (albedo and normal guides)
layout(set = 0, binding = 7, rgba32f) uniform image2D albedoImage;
layout(set = 0, binding = 8, rgba32f) uniform image2D normalImage;

layout(set = 0, binding = 5) uniform CameraUBO {
    mat4 invView;
    mat4 invProj;
    vec3 position;
    float fov;
    vec2 resolution;
    float nearPlane;
    float farPlane;
} camera;

// Light buffer - use scalar layout to match C++ struct packing
struct GPULight {
    vec3 position;
    uint type;       // 0=Directional, 1=Point, 2=Spot, 3=Area
    vec3 color;
    float intensity;
    vec3 direction;
    float range;
    float innerAngle;
    float outerAngle;
    vec2 padding;
};

layout(scalar, set = 0, binding = 9) readonly buffer LightBuffer {
    GPULight lights[];
};

// Light types
const uint LIGHT_DIRECTIONAL = 0u;
const uint LIGHT_POINT = 1u;
const uint LIGHT_SPOT = 2u;
const uint LIGHT_AREA = 3u;

layout(push_constant) uniform PushConstants {
    uint frameIndex;
    uint sampleIndex;
    uint maxBounces;
    float clampValue;
} pc;

// Ray payload: carries radiance, throughput, hit info for multi-bounce
struct RayPayload {
    vec3 radiance;
    vec3 throughput;
    vec3 hitPos;
    vec3 hitNormal;
    vec3 nextDir;
    uint seed;
    bool hit;
    bool done;
    // Material properties at hit
    vec3 albedo;
    vec3 emissive;
    float metallic;
    float roughness;
};

layout(location = 0) rayPayloadEXT RayPayload payload;

const float PI = 3.14159265359;
const float MAX_DIST = 10000.0;
// Soft shadow tuning (in world units / radians)
const float SUN_ANGULAR_RADIUS = 0.00935;  // ~0.535 deg diameter -> ~0.2675 deg radius
const float POINT_LIGHT_RADIUS = 0.15;     // makes point lights behave like small sphere lights

// PCG random
uint pcgHash(uint v) {
    uint state = v * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float randomFloat(inout uint seed) {
    seed = pcgHash(seed);
    return float(seed) / 4294967295.0;
}

vec3 randomInUnitSphere(inout uint seed) {
    // Not perfectly uniform, but good enough for soft shadow jitter
    vec3 p = vec3(
        randomFloat(seed) * 2.0 - 1.0,
        randomFloat(seed) * 2.0 - 1.0,
        randomFloat(seed) * 2.0 - 1.0
    );
    return normalize(p);
}

vec3 sampleCone(vec3 axis, float cosMaxAngle, inout uint seed) {
    // Uniform cone sampling around axis
    float u1 = randomFloat(seed);
    float u2 = randomFloat(seed);
    float cosTheta = mix(cosMaxAngle, 1.0, u1);
    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));
    float phi = 2.0 * PI * u2;
    
    vec3 w = normalize(axis);
    vec3 up = (abs(w.y) < 0.999) ? vec3(0, 1, 0) : vec3(1, 0, 0);
    vec3 u = normalize(cross(up, w));
    vec3 v = cross(w, u);
    
    return normalize(u * (cos(phi) * sinTheta) + v * (sin(phi) * sinTheta) + w * cosTheta);
}

// Sky color (simple gradient)
vec3 getSkyColor(vec3 direction) {
    float t = 0.5 * (direction.y + 1.0);
    // Keep the environment relatively dim so explicit scene lights dominate (otherwise light direction changes are hard to notice).
    vec3 skyColor = mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t) * 0.05;
    
    // Add sun disc for any directional lights
    uint numLights = lights.length();
    for (uint i = 0; i < numLights; i++) {
        if (lights[i].type == LIGHT_DIRECTIONAL) {
            float sunDot = dot(direction, lights[i].direction);
            if (sunDot > 0.995) {
                skyColor += lights[i].color * lights[i].intensity * 2.0;
            } else if (sunDot > 0.98) {
                float sunGlow = (sunDot - 0.98) / 0.015;
                skyColor += lights[i].color * lights[i].intensity * sunGlow * 0.5;
            }
        }
    }
    
    return skyColor;
}

// Trace shadow ray - returns visibility (1 = lit, 0 = shadow)
// IMPORTANT: for point/spot lights we must clamp tMax to the light distance,
// otherwise geometry *behind the light* can incorrectly occlude it.
float traceShadow(vec3 origin, vec3 direction, float tMax) {
    // Use a simple payload for shadow - the miss shader will set it to 1.0
    payload.radiance = vec3(0.0);  // Will be set to 1.0 on miss
    
    traceRayEXT(topLevelAS,
                gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT,
                0xFF,
                1, 2, 1,  // shadow ray type
                origin, 0.001, direction, tMax,
                0);
    
    return payload.radiance.x;
}

void main() {
    const uvec2 pixel = gl_LaunchIDEXT.xy;
    const uvec2 size = gl_LaunchSizeEXT.xy;
    
    // Initialize RNG
    uint seed = pcgHash(pixel.x + pixel.y * size.x + pc.frameIndex * 1000000u + pc.sampleIndex * 10000u);
    
    // Jittered UV for anti-aliasing
    vec2 jitter = vec2(randomFloat(seed), randomFloat(seed)) - 0.5;
    vec2 uv = (vec2(pixel) + 0.5 + jitter) / vec2(size);
    
    // Generate ray
    vec2 ndc = uv * 2.0 - 1.0;
    vec4 clipPos = vec4(ndc, -1.0, 1.0);
    vec4 viewPos = camera.invProj * clipPos;
    viewPos = viewPos / viewPos.w;
    vec4 worldPos = camera.invView * viewPos;
    
    vec3 origin = camera.position;
    vec3 direction = normalize(worldPos.xyz - camera.position);
    
    // Path tracing loop
    vec3 radiance = vec3(0.0);
    vec3 throughput = vec3(1.0);
    
    // AOV storage for denoiser (first-hit values)
    vec3 firstHitAlbedo = vec3(0.0);
    vec3 firstHitNormal = vec3(0.0);
    bool capturedAOV = false;
    
    for (uint bounce = 0; bounce <= pc.maxBounces; bounce++) {
        // Initialize payload
        payload.radiance = vec3(0.0);
        payload.throughput = throughput;
        payload.seed = seed;
        payload.hit = false;
        payload.done = false;
        
        // Trace ray
        traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF,
                    0, 2, 0,  // primary ray type
                    origin, 0.001, direction, 10000.0, 0);
        
        seed = payload.seed;
        
        if (!payload.hit) {
            // Miss - add sky contribution
            vec3 skyColor = getSkyColor(direction);
            radiance += throughput * skyColor;
            
            // For sky hits on first bounce, use sky as albedo
            if (!capturedAOV) {
                firstHitAlbedo = skyColor;
                firstHitNormal = -direction * 0.5 + 0.5;  // Remap to [0,1]
            }
            break;
        }
        
        // Capture first-hit AOVs for denoiser
        if (!capturedAOV) {
            firstHitAlbedo = payload.albedo;
            firstHitNormal = payload.hitNormal * 0.5 + 0.5;  // Remap to [0,1]
            capturedAOV = true;
        }
        
        // Add emissive contribution
        radiance += throughput * payload.emissive;
        
        // Direct lighting from scene lights
        vec3 shadowOrigin = payload.hitPos + payload.hitNormal * 0.001;
        
        uint numLights = lights.length();
        for (uint i = 0; i < numLights; i++) {
            GPULight light = lights[i];
            
            vec3 lightDir;
            float lightDist = MAX_DIST;
            float attenuation = 1.0;
            vec3 sampledPos = light.position;
            
            if (light.type == LIGHT_DIRECTIONAL) {
                // Soft sun: jitter direction within a small cone
                float cosMax = cos(SUN_ANGULAR_RADIUS);
                lightDir = sampleCone(light.direction, cosMax, seed);
            } else if (light.type == LIGHT_POINT || light.type == LIGHT_SPOT) {
                // Soft point/spot: treat as a small sphere light around its position
                sampledPos = light.position + randomInUnitSphere(seed) * POINT_LIGHT_RADIUS;
                vec3 toLight = sampledPos - payload.hitPos;
                lightDist = length(toLight);
                lightDir = toLight / lightDist;
                
                // Distance attenuation
                if (light.range > 0.0) {
                    attenuation = 1.0 - clamp(lightDist / light.range, 0.0, 1.0);
                    attenuation *= attenuation;
                } else {
                    attenuation = 1.0 / (lightDist * lightDist + 1.0);
                }
                
                // Spot cone
                if (light.type == LIGHT_SPOT) {
                    float theta = dot(-lightDir, light.direction);
                    float cosInner = cos(light.innerAngle);
                    float cosOuter = cos(light.outerAngle);
                    float denom = max(cosInner - cosOuter, 0.0001);
                    float spotFactor = clamp((theta - cosOuter) / denom, 0.0, 1.0);
                    attenuation *= spotFactor;
                }
            } else {
                continue;
            }
            
            float NdotL = max(dot(payload.hitNormal, lightDir), 0.0);
            if (NdotL <= 0.0 || attenuation <= 0.0) continue;
            
            // Shadow ray
            float shadowTMax = (light.type == LIGHT_DIRECTIONAL) ? MAX_DIST : max(lightDist - 0.01, 0.01);
            float visibility = traceShadow(shadowOrigin, lightDir, shadowTMax);
            if (visibility <= 0.0) continue;
            
            // Check if shadow ray hits something before the light
            // (For point/spot lights - directional lights have infinite distance)
            if (light.type != LIGHT_DIRECTIONAL) {
                // We need to test if occluder is closer than light
                // For now, we use the simple visibility check
            }
            
            vec3 diffuseColor = payload.albedo * (1.0 - payload.metallic);
            vec3 directLight = diffuseColor * light.color * light.intensity * NdotL * attenuation * visibility / PI;
            radiance += throughput * directLight;
        }
        
        // Update throughput for next bounce
        // For metals, tint by albedo; for non-metals, mostly white specular
        vec3 F0 = mix(vec3(0.04), payload.albedo, payload.metallic);
        float cosTheta = max(dot(-direction, payload.hitNormal), 0.0);
        vec3 fresnel = F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
        
        // Blend diffuse and specular contribution to throughput
        vec3 diffuseThroughput = payload.albedo * (1.0 - payload.metallic) * (1.0 - fresnel);
        vec3 specularThroughput = fresnel;
        throughput *= mix(diffuseThroughput, specularThroughput, payload.metallic);
        
        // Russian roulette after first few bounces
        if (bounce > 2) {
            float p = max(throughput.x, max(throughput.y, throughput.z));
            if (randomFloat(seed) > p) {
                break;
            }
            throughput /= p;
        }
        
        // Setup next ray
        origin = payload.hitPos + payload.hitNormal * 0.001;
        direction = payload.nextDir;
        
        // Early termination if throughput is negligible
        if (max(throughput.x, max(throughput.y, throughput.z)) < 0.001) {
            break;
        }
    }
    
    // Clamp fireflies
    if (pc.clampValue > 0.0) {
        float luminance = dot(radiance, vec3(0.2126, 0.7152, 0.0722));
        if (luminance > pc.clampValue) {
            radiance *= pc.clampValue / luminance;
        }
    }
    
    // Accumulate color
    vec4 prevColor = imageLoad(accumImage, ivec2(pixel));
    float sampleWeight = 1.0 / float(pc.sampleIndex + 1);
    vec3 accumulated = mix(prevColor.rgb, radiance, sampleWeight);
    imageStore(accumImage, ivec2(pixel), vec4(accumulated, 1.0));
    
    // Accumulate AOVs (albedo and normal - these converge quickly)
    vec4 prevAlbedo = imageLoad(albedoImage, ivec2(pixel));
    vec4 prevNormal = imageLoad(normalImage, ivec2(pixel));
    vec3 accumAlbedo = mix(prevAlbedo.rgb, firstHitAlbedo, sampleWeight);
    vec3 accumNormal = mix(prevNormal.rgb, firstHitNormal, sampleWeight);
    imageStore(albedoImage, ivec2(pixel), vec4(accumAlbedo, 1.0));
    imageStore(normalImage, ivec2(pixel), vec4(accumNormal, 1.0));
}

